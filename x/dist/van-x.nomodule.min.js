{window.vanX={};let e,t,r=Object,{get:o,set:l,deleteProperty:n,ownKeys:f}=Reflect,i=Symbol,{state:a,derive:d,add:s,tags:c}=van,u=1e3,w=i(),y=i(),m=i(),v=i(),g=i(),p=i(),D=e=>(e[m]=1,e),P=e=>e[m]?d(()=>_(e())):a(_(e)),_=e=>{if(!(e instanceof r)||e[w])return e;let t=new Proxy((e[w]=r.fromEntries(r.entries(e).map(([e,t])=>[e,P(t)])),e[y]=e,e[v]=[],e[g]=a(1),e),{get:(e,r)=>e[w][r]?.val??o(e,r,t),set(e,t,r){let o=e[w];if(t in o)return o[t].val=_(r),1;let n=t in e;return l(e,t,r)?(n||l(o,t,P(r))&&(++e[g].val,j(e,t,o[t])),1):void 0},deleteProperty:(e,t)=>(n(e[w],t)&&x(e,t),n(e,t)&&++e[g].val),ownKeys:e=>(e[g].val,f(e))});return t},b=e=>e[w],A=e=>e[v]=e[v].filter(e=>e.t.isConnected),K=(e,t,r,o)=>()=>{let l=o(r,()=>delete e[t]);return l[p]=t,l},S=(e,t,o,{t:l,f:n},f)=>{if(s(l,K(e,t,o,n)),!f&&Array.isArray(e)&&t!=e.length-1){let t={};for(let e of l.childNodes)t[e[p]]=e;let o=l.firstChild;for(let n of r.keys(e))o===t[n]?o=o.nextSibling:l.insertBefore(t[n],o)}},j=(e,r,o)=>A(e).forEach(S.bind(t,e,r,o)),x=(e,t)=>{for(let r of A(e))[...r.t.childNodes].find(e=>e[p]===t)?.remove()},F=r=>(e??(setTimeout(()=>(e.forEach(A),e=t),u),e=new Set)).add(r),O=(e,t,o)=>{let l={t:e(),f:o};t[v].push(l),F(t);for(let[e,o]of r.entries(t[w]))S(t,e,o,l,1);return l.t},R=(e,t)=>{let o=Array.isArray(e)?r.entries(t(e.filter(e=>1))):t(r.entries(e)),l=e[y],n=r.fromEntries(o),f=e[w],i=r.fromEntries(o.map(([e,t])=>{let r=f[e];return r?r.val=t:r=P(t),[e,r]}));for(let{t:t,f:o}of A(e)){let l={};for(let e of[...t.childNodes])e[p]in i?l[e[p]]=e:e.remove();let n=t.firstChild;for(let[f,a]of r.entries(i))n===l[f]?n=n.nextSibling:t.insertBefore(l[f]??c.div(K(e,f,a,o)).firstChild,n)}for(let e in l)delete l[e];for(let e in n)l[e]=n[e];e[w]=i};window.vanX={calc:D,reactive:_,stateFields:b,list:O,replace:R}}