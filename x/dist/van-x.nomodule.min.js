{window.vanX={};let e,t,r=Object,{get:l,set:o,deleteProperty:n}=Reflect,f=Symbol,{state:i,derive:a,add:d,tags:c}=van,s=1e3,u=f(),w=f(),y=f(),m=f(),v=f(),g=e=>(e[y]=1,e),p=e=>e[y]?a(()=>D(e())):i(D(e)),D=e=>{if(!(e instanceof r)||e[u])return e;let t=new Proxy((e[u]=r.fromEntries(r.entries(e).map(([e,t])=>[e,p(t)])),e[w]=e,e[m]=[],e),{get:(e,r)=>e[u][r]?.val??l(e,r,t),set(e,t,r){let l=e[u];if(t in l)return l[t].val=D(r),1;let n=t in e;return o(e,t,r)?(n||o(l,t,p(r))&&S(e,t,l[t]),1):void 0},deleteProperty:(e,t)=>(n(e[u],t)&&j(e,t),n(e,t))});return t},P=e=>e[u],_=e=>e[m]=e[m].filter(e=>e.t.isConnected),b=(e,t,r,l)=>()=>{let o=l(r,()=>delete e[t]);return o[v]=t,o},A=(e,t,l,{t:o,f:n},f)=>{if(d(o,b(e,t,l,n)),!f&&Array.isArray(e)&&t!=e.length-1){let t={};for(let e of o.childNodes)t[e[v]]=e;let l=o.firstChild;for(let n of r.keys(e))l===t[n]?l=l.nextSibling:o.insertBefore(t[n],l)}},S=(e,r,l)=>_(e).forEach(A.bind(t,e,r,l)),j=(e,t)=>{for(let r of _(e))[...r.t.childNodes].find(e=>e[v]===t)?.remove()},x=r=>(e??(setTimeout(()=>(e.forEach(_),e=t),s),e=new Set)).add(r),F=(e,t,l)=>{let o={t:e(),f:l};t[m].push(o),x(t);for(let[e,l]of r.entries(t[u]))A(t,e,l,o,1);return o.t},O=(e,t)=>{let l=Array.isArray(e)?r.entries(t(e.filter(e=>1))):t(r.entries(e)),o=e[w],n=r.fromEntries(l),f=e[u],i=r.fromEntries(l.map(([e,t])=>{let r=f[e];return r?r.val=t:r=p(t),[e,r]}));for(let{t:t,f:l}of _(e)){let o={};for(let e of[...t.childNodes])e[v]in i?o[e[v]]=e:e.remove();let n=t.firstChild;for(let[f,a]of r.entries(i))n===o[f]?n=n.nextSibling:t.insertBefore(o[f]??c.div(b(e,f,a,l)).firstChild,n)}for(let e in o)delete o[e];for(let e in n)o[e]=n[e];e[u]=i};window.vanX={calc:g,reactive:D,stateFields:P,list:F,replace:O}}