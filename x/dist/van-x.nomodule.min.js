{window.vanX={};let e=Object,{get:t,set:r,deleteProperty:l}=Reflect,n=Symbol,{state:i,derive:o}=van,f=n(),d=n(),s=n(),u=e=>(e[d]=1,e),w=e=>e[d]?o(()=>y(e())):i(y(e)),y=n=>{if(!(n instanceof e))return n;let i=new Proxy((n[f]=new Proxy(e.fromEntries(e.entries(n).map(([e,t])=>[e,w(t)])),{deleteProperty:(e,t)=>l(e,t)&&l(n,t)}),n),{get:(e,r)=>e[f][r]?.val??t(e,r,i),set:(e,t,l)=>{let n=e[f];return t in n?(n[t].val=y(l),1):(t in e||r(n,t,w(l)),r(e,t,l))}});return i},a=e=>e[f],c=e=>new Proxy(e,{deleteProperty:(e,t)=>l(e,t)&&(e[s][t].remove(),1)}),P=(t,r,l)=>{let n=o(()=>c(r.val[f]??r.val));return r=>{let i=n.val;if(!r){let r=i[s]={};return t(e.entries(i).map(([e,t])=>r[e]=l(t,()=>delete n.val[e])))}let o=n.oldVal;if(i===o)return r;let f=i[s]=o[s],d=new Set;for(let e in o)e in i||(delete o[e],delete f[e]);let u=e.keys(o),w=0,y=[];for(let[t,s]of e.entries(i)){let e=u[w];if(t in o){let l=i[t]=o[t];if(l.val!==s.val&&y.push([l,s.val]),t===e)for(;d.has(u[++w]););else r.insertBefore(f[t],f[e]),d.add(t)}else r.insertBefore(f[t]=l(s,()=>delete n.val[t]),f[e])}return setTimeout(()=>{for(let[e,t]of y)e.val=t}),r}};window.vanX={calc:u,reactive:y,stateFields:a,list:P}}