{window.vanX={};let e=Object,t=Reflect,r=Symbol,{state:l,derive:n}=van,i=r(),o=r(),d=r(),f=e=>(e[o]=1,e),w=e=>e[o]?n(()=>s(e())):l(s(e)),s=r=>{if(!(r instanceof e))return r;let l=new Proxy((r[i]=new Proxy(e.fromEntries(e.entries(r).map(([e,t])=>[e,w(t)])),{deleteProperty:(e,l)=>t.deleteProperty(e,l)&&t.deleteProperty(r,l)}),r),{get:(e,r)=>e[i][r]?.val??t.get(e,r,l),set:(e,r,l)=>{let n=e[i];return r in n?(n[r].val=s(l),1):(r in e||t.set(n,r,w(l)),t.set(e,r,l))}});return l},u=e=>e[i],y=e=>new Proxy(e,{deleteProperty:(e,r)=>t.deleteProperty(e,r)&&(e[d][r].remove(),1)}),a=(t,r,l)=>{let o=n(()=>y(r.val[i]??r.val));return n=>{let i=o.val;if(!n){let r=i[d]={};return t(e.entries(i).map(([e,t])=>r[e]=l(t,()=>delete o.val[e])))}if(r.val===r.oldVal)return n;let f=o.oldVal,w=i[d]=f[d],s=new Set;for(let e in f)e in i||(delete f[e],delete w[e]);let u=e.keys(f),y=0;for(let[t,r]of e.entries(i)){let e=u[y];if(t in u)if(f[t].val=r.val,i[t]=f[t],t===e)do{}while(s.has(u[++y]));else n.insertBefore(w[t],w[e]),s.add(t);else n.insertBefore(w[t]=l(r,()=>delete o.val[t]),w[e])}return n}};window.vanX={calc:f,reactive:s,stateFields:u,keyedItems:a}}