{window.vanX={};let e=Object,{get:t,set:r,deleteProperty:l}=Reflect,n=Symbol,{state:i,derive:o}=van,d=n(),f=n(),s=n(),w=e=>(e[f]=1,e),y=e=>e[f]?o(()=>u(e())):i(u(e)),u=n=>{if(!(n instanceof e))return n;let i=new Proxy((n[d]=new Proxy(e.fromEntries(e.entries(n).map(([e,t])=>[e,y(t)])),{deleteProperty:(e,t)=>l(e,t)&&l(n,t)}),n),{get:(e,r)=>e[d][r]?.val??t(e,r,i),set:(e,t,l)=>{let n=e[d];return t in n?(n[t].val=u(l),1):(t in e||r(n,t,y(l)),r(e,t,l))}});return i},a=e=>e[d],c=e=>new Proxy(e,{deleteProperty:(e,t)=>l(e,t)&&(e[s][t].remove(),1)}),P=(t,r,l)=>{let n=o(()=>c(r.val[d]??r.val));return i=>{let o=n.val;if(!i){let r=o[s]={};return t(e.entries(o).map(([e,t])=>r[e]=l(t,()=>delete n.val[e])))}if(r.val===r.oldVal)return i;let d=n.oldVal,f=o[s]=d[s],w=new Set;for(let e in d)e in o||(delete d[e],delete f[e]);let y=e.keys(d),u=0;for(let[t,r]of e.entries(o)){let e=y[u];if(t in y)if(d[t].val=r.val,o[t]=d[t],t===e)do{}while(w.has(y[++u]));else i.insertBefore(f[t],f[e]),w.add(t);else i.insertBefore(f[t]=l(r,()=>delete n.val[t]),f[e])}return i}};window.vanX={calc:w,reactive:u,stateFields:a,keyedItems:P}}