{window.vanX={};let e=Object,t=Reflect,l=Symbol,{state:r,derive:n}=van,i=l(),d=l(),o=l(),f=e=>(e[d]=1,e),s=e=>e[d]?n(()=>w(e())):r(w(e)),w=l=>{if(!(l instanceof e))return l;let r=new Proxy((l[i]=e.fromEntries(e.entries(l).map(([e,t])=>[e,s(t)])),l),{get:(e,l)=>e[i][l]?.val??t.get(e,l,r),set:(e,l,r)=>{let n=e[i];return l in n?(n[l].val=w(r),1):(l in e||t.set(n,l,s(r)),t.set(e,l,r))}});return r},u=e=>e[i],a=e=>new Proxy(e,{deleteProperty:(e,l)=>t.deleteProperty(e,l)&&(e[o][l].remove(),1)}),c=(t,l,r)=>{let d=n(()=>a(l.val[i]??l.val));return n=>{let i=d.val;if(!n){let l=i[o]={};return t(e.entries(i).map(([e,t])=>l[e]=r(t,()=>delete d.val[e])))}if(l.val===l.oldVal)return n;let f=d.oldVal,s=i[o]=f[o],w=new Set;for(let e in f)e in i||(delete f[e],delete s[e]);let u=e.keys(f),a=0;for(let[t,l]of e.entries(i)){let e=u[a];if(t in u)if(f[t].val=l.val,i[t]=f[t],t===e)do{}while(w.has(u[++a]));else n.insertBefore(s[t],s[e]),w.add(t);else n.insertBefore(s[t]=r(l,()=>delete d.val[t]),s[e])}return n}};window.vanX={calc:f,reactive:w,stateFields:u,keyedItems:c}}