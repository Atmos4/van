{window.vanX={};let e,t,{fromEntries:r,entries:o,keys:l}=Object,{get:n,set:f,deleteProperty:i,ownKeys:a}=Reflect,s=Symbol,{state:c,derive:d,add:y,tags:u}=van,w=1e3,m=s(),g=s(),v=s(),b=s(),p=s(),D=s(),P=e=>(e[v]=1,e),_=e=>e[v]?d(()=>j(e())):c(j(e)),j=e=>{if(!(e instanceof Object)||e[m])return e;let t=new Proxy((e[m]=r(o(e).map(([e,t])=>[e,_(t)])),e[g]=e,e[b]=[],e[p]=c(1),e),{get:(e,r)=>e[m][r]?.val??("length"===r&&e[p].val,n(e,r,t)),set(e,r,o){let l=e[m];if(r in l)return l[r].val=j(o),1;let n=r in e;return f(e,r,o)?(n||f(l,r,_(o))&&(++e[p].val,h(t,r,l[r])),1):void 0},deleteProperty:(e,t)=>(i(e[m],t)&&k(e,t),i(e,t)&&++e[p].val),ownKeys:e=>(e[p].val,a(e))});return t},A=e=>e[m],K=e=>e[b]=e[b].filter(e=>e.t.isConnected),O=(e,t,r,o)=>()=>{let l=o(r,()=>delete e[t]);return l[D]=t,l},S=(e,t,r,{t:o,f:n},f)=>{if(y(o,O(e,t,r,n)),!f&&Array.isArray(e)&&t!=e.length-1){let t={};for(let e of o.childNodes)t[e[D]]=e;let r=o.firstChild;for(let n of l(e))r===t[n]?r=r.nextSibling:o.insertBefore(t[n],r)}},h=(e,r,o)=>K(e).forEach(S.bind(t,e,r,o)),k=(e,t)=>{for(let r of K(e))[...r.t.childNodes].find(e=>e[D]===t)?.remove()},x=r=>(e??(setTimeout(()=>(e.forEach(K),e=t),w),e=new Set)).add(r),E=(e,t,r)=>{let l={t:e(),f:r};t[b].push(l),x(t);for(let[e,r]of o(t[m]))S(t,e,r,l,1);return l.t},F=(e,t)=>{let l=Array.isArray(e)?o(t(e.filter(e=>1))):t(o(e)),n=e[g],f=r(l),i=e[m],a=r(l.map(([e,t])=>{let r=i[e];return r?r.val=t:r=_(t),[e,r]}));for(let{t:t,f:r}of K(e)){let l={};for(let e of[...t.childNodes])e[D]in a?l[e[D]]=e:e.remove();let n=t.firstChild;for(let[f,i]of o(a))n===l[f]?n=n.nextSibling:t.insertBefore(l[f]??u.div(O(e,f,i,r)).firstChild,n)}for(let e in n)delete n[e];for(let e in f)n[e]=f[e];e[m]=a,++e[p].val};window.vanX={calc:P,reactive:j,stateFields:A,list:E,replace:F}}